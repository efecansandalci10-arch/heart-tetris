<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>üíñ Efe'nin Kalpleriyle Tetris üíñ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

<style>
*{margin:0;padding:0;box-sizing:border-box;}

body{
  background:linear-gradient(180deg,#1a0015,#000);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  height:100vh;
  font-family:Arial, sans-serif;
  color:white;
}

h1{
  margin-bottom:10px;
  color:#ff4e8a;
  text-shadow:0 0 15px #ff2e88;
}

#score{
  margin-bottom:10px;
  color:#ffc0da;
}

canvas{
  background:#111;
  box-shadow:0 0 25px #ff2e88;
  border-radius:10px;
}

.controls{
  margin-top:15px;
  display:flex;
  gap:10px;
}

button{
  padding:14px 18px;
  font-size:18px;
  border:none;
  border-radius:50px;
  background:linear-gradient(45deg,#ff2e88,#ff4e8a);
  color:white;
}
</style>
</head>
<body>

<h1>üíñ Heart Tetris üíñ</h1>
<div id="score">Score: 0</div>
<canvas id="game"></canvas>

<div class="controls">
  <button onclick="move(-1)">‚¨ÖÔ∏è</button>
  <button onclick="rotate()">üîÑ</button>
  <button onclick="move(1)">‚û°Ô∏è</button>
  <button onclick="drop()">‚¨áÔ∏è</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
let SIZE = Math.floor(window.innerWidth / 12);

canvas.width = COLS * SIZE;
canvas.height = ROWS * SIZE;

let board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let score = 0;

const shapes = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]],
  [[0,1,1],[1,1,0]],
  [[1,1,0],[0,1,1]]
];

let lastShapeIndex = -1;

function rotateMatrix(matrix){
  return matrix[0].map((_,i)=>
    matrix.map(row=>row[i]).reverse()
  );
}

function randomShape(){
  let index;
  do {
    index = Math.floor(Math.random()*shapes.length);
  } while(index === lastShapeIndex);

  lastShapeIndex = index;

  let shape = JSON.parse(JSON.stringify(shapes[index]));

  let rotations = Math.floor(Math.random()*4);
  for(let i=0;i<rotations;i++){
    shape = rotateMatrix(shape);
  }

  return shape;
}

function createPiece(){
  const shape = randomShape();
  return {
    shape: shape,
    x: Math.floor((COLS - shape[0].length)/2),
    y: 0
  };
}

let piece = createPiece();

function drawCell(x,y){
  ctx.font = (SIZE-6)+"px Arial";
  ctx.textAlign="center";
  ctx.fillText("üíñ",x*SIZE+SIZE/2,y*SIZE+SIZE/1.2);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(board[r][c]) drawCell(c,r);
    }
  }

  piece.shape.forEach((row,r)=>{
    row.forEach((val,c)=>{
      if(val) drawCell(piece.x+c,piece.y+r);
    });
  });
}

function collide(){
  for(let r=0;r<piece.shape.length;r++){
    for(let c=0;c<piece.shape[r].length;c++){
      if(piece.shape[r][c]){
        let newX = piece.x + c;
        let newY = piece.y + r;
        if(newX<0||newX>=COLS||newY>=ROWS||board[newY]?.[newX]){
          return true;
        }
      }
    }
  }
  return false;
}

function merge(){
  piece.shape.forEach((row,r)=>{
    row.forEach((val,c)=>{
      if(val){
        board[piece.y+r][piece.x+c]=1;
      }
    });
  });
}

function clearLines(){
  let lines = 0;

  board = board.filter(row=>{
    if(row.every(cell=>cell)){
      lines++;
      return false;
    }
    return true;
  });

  while(board.length<ROWS){
    board.unshift(Array(COLS).fill(0));
  }

  if(lines){
    score += lines*10;
    document.getElementById("score").innerText="Score: "+score;
  }
}

function newPiece(){
  piece = createPiece();
  if(collide()){
    alert("üíî Game Over üíî");
    board = Array.from({length:ROWS},()=>Array(COLS).fill(0));
    score=0;
    document.getElementById("score").innerText="Score: 0";
  }
}

function move(dir){
  piece.x+=dir;
  if(collide()) piece.x-=dir;
  draw();
}

function rotate(){
  const old = piece.shape;
  piece.shape = rotateMatrix(piece.shape);
  if(collide()) piece.shape = old;
  draw();
}

function drop(){
  piece.y++;
  if(collide()){
    piece.y--;
    merge();
    clearLines();
    newPiece();
  }
  draw();
}

setInterval(drop,600);
draw();
</script>

</body>
</html>
